#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRLeft,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     Compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     none,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     Conveyor,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lock,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

 #pragma DebuggerWindows("debugStream")
 #pragma DebuggerWindows("Motors")

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#define START_RED     "Red"
#define START_BLUE    "Blue"
#define START_FLOOR  "FLOOR"
#define START_RAMP "RAMP"
#define TRUE 1
#define FALSE 0
string startColor;
string startPosition;
int GoalPosition =0;//must be initialized as zero so it can overide when/if LocateInfaRedBeacon() produces no change

task printf();
void getUserInput();
void initializeRobot();
void Routine1();
void Routine2();
void Routine3();
void RoutineERR();
void locateInfaRedBeacon();
void RunLift(float nStage);
void Drive(int distance, int power);
void Turn(int Angle);// +360 to -360
void BumpConveyor();
void Test();
task main()
{
	startTask(printf);
//	getUserInput();
	initializeRobot();
	//	Test();
	waitForStart();

	Drive(-108, 30);
	wait10Msec(150);
	servo[Gripper]=0;
	wait10Msec(100);
	servo[lock]=225;
	wait10Msec(200);
	servo[lock]=127;
	wait10Msec(.75)
	Turn(30);
	wait10Msec(50);
	Drive(101, 50);
	Turn(-90);
	//locateInfaRedBeacon();//determins GoalPosition
	//for(int Count=0; Count<3; Count++)
	//{
	//	if(GoalPosition==1){
	//	Routine1();
	//	break;
	//	}
	//	else if(GoalPosition==2){
	//	Routine2();
	//	break;
	//	}
	//	else if(GoalPosition==3){
	//	Routine3();
	//	break;
	//	}
	//	else if(GoalPosition==0){
	//	RoutineERR();
	//	break;
	//	}
	// }
	////	Test();
	//waitForStart();
	//locateInfaRedBeacon();//determins GoalPosition

	///*    hows this for instead of your routine stuffs     -David

	//int fabulus =0;

	//while (int fabulus==0)
 // {
 //  	if(SensorValue[IRLeft]==5)
	//	{
	//	Routine1();
	//	break;
	//	}
	//	else
	//	{
	//	Drive(5);//change number
	//	Turn(-45);//change number
	//	Drive(5);//change number
	//	}

	//	if(SensorValue[IRLeft]==5)
	//	{
	//	Routine2();
	//	break;
	//	}
	//	else
	//	{
	//	Drive(5);//change number
	//	Turn(-45);//change number
	//	Drive(5);//change number
	//	}

	//if(SensorValue[IRLeft]==5)
	//	{
	//	Routine3();
	//	break;
	//	}
	//	else
	//	{
	//	Drive(5);//change number
	//	Turn(-45);//change number
	//	Drive(5);//change number
	//	}
	//	int fabulus++;

 // }

	//if(SensorValue[IRLeft]==5)
	//	{
	//	RoutineERR();
	//	break;
	//	}
	//*/




	//for(int Count=0; Count<3; Count++)
	//{
	//	if(GoalPosition==1)
	//	{
	//	Routine1();
	//	break;
	//	}

	//	else if(GoalPosition==2)
	//	{
	//	Routine2();
	//	break;
	//	}

	//	else if(GoalPosition==3)
	//	{
	//	Routine3();
	//	break;
	//	}

	//	else if(GoalPosition==0)
	//	{
	//	RoutineERR();
	//	break;
	//	}
	//}
	//clearDebugStream();
}

task printf()
{
	while(true)
	{
	clearDebugStream();
	writeDebugStreamLine("startPosition: %s", startPosition);
	writeDebugStreamLine("startColor:    %s", startColor);
	writeDebugStreamLine("GoalPosition: %i", GoalPosition);
	wait10Msec(100);
	clearDebugStream();
	}
}
void initializeRobot()
{
	servo[Gripper]=127;
}
void getUserInput()
{
  disableDiagnosticsDisplay();
  nxtDisplayCenteredTextLine(0, "Red or Blue?");
  nxtDisplayCenteredTextLine(7, "Red Blue");
  while(true)
  {
    if(nNxtButtonPressed == 2)
    {
      startColor = START_RED;
      nxtDisplayCenteredTextLine(0, "Red");
      break;
    }
    else if(nNxtButtonPressed == 1)
    {
      startColor = START_BLUE;
      nxtDisplayCenteredTextLine(0, "Blue");
      break;
    }
  }
  playSound(soundBlip);
  wait1Msec(1000);
  nxtDisplayCenteredTextLine(1, "FLOOR or RAMP?");
  nxtDisplayCenteredTextLine(7, "FLOOR RAMP");
  while(true)
  {
    if(nNxtButtonPressed == 2)
    {
      startPosition = START_FLOOR;
      nxtDisplayCenteredTextLine(1, "FLOOR");
      nxtDisplayCenteredTextLine(7, "");
      break;
    }
    else if(nNxtButtonPressed == 1)
    {
      startPosition = START_RAMP;
      nxtDisplayCenteredTextLine(1, "RAMP");
      nxtDisplayCenteredTextLine(7, "");
      break;
    }
  }
  playSound(soundFastUpwardTones);
  wait10Msec(200);
  bDisplayDiagnostics = false;
	nxtDisplayCenteredTextLine(0, "%s, %s",startColor, startPosition);
}

void Routine1()
{
//Turn(-90);
////Drive(1.5);
////Drive(-1.5);
//RunLift(4);
//BumpConveyor();
////Drive(1.5);
//RunLift(-4);
////Drive(-1.5);
//Turn(90);
////Drive(12);
//Turn(90);
//Drive(36);
}
void Routine2()
{

}
void Routine3()
{

}
void RoutineERR()
{

}
void locateInfaRedBeacon()
{
//determine start Position(FLOOR = floor, RAMP = ramp)
	if(startPosition == START_FLOOR)
	{
	//drive out of start Position and into GoalPosition_1
	//Drive(40);//change number
	//Turn(-90);//change number
	}
	else if(startPosition == START_RAMP)
	{

			//drive out of start Position and into GoalPosition_1
	//Drive(75);
	//Turn(-45);
	//Drive(-52);
	//Turn(-45);
	//Drive(-24);

	////drive out of start Position and into GoalPosition_1
	//Drive(80);
	//Turn(-45);
	//Drive(-50);//change number
	//Turn(-45);//change number
	//Drive(-25);//change number
	}

//check IR when robot has reached GoalPosition1
	if(SensorValue[IRLeft]==5)
	{
	GoalPosition = 1
	RunLift(4);//is this like routine one?  -David

	}

//if IR at GoalPosition 1 SET(int GoalPosition =1)and return;
//else drive out of GoalPosition1 and into GoalPosition_2
//check IR when robot has reached GoalPosition_2
//if IR at GoalPosition 2 SET(int GoalPosition =2)and return;
//else drive out of GoalPosition2 and into GoalPosition_3
//check IR when robot has reached GoalPosition_3
//if IR at GoalPosition 3 SET(int GoalPosition =1)and return;
}
void RunLift(float nStage)
{
 float Range=22.5;//mechanical rotations of the motor shaft to extend full length of lift
 float Stages=4;//number of stages
 float ppr= 1120;//pulse per revolution for the andymark motor
 float nTarget=(nStage/Stages)*(Range *ppr);
 writeDebugStreamLine("Target: %f, nStage: %i", nTarget,nStage);//nStage is reading but nTarget is still 0???
 if(nTarget>1)//run up
 {
		while(nMotorEncoder[Lift]<=nTarget)
		{
		float nFeedBack=(nMotorEncoder[Lift]/1120)/22.5;
		writeDebugStreamLine("Value :%f Target: %f, Location: %f", nMotorEncoder[Lift], nTarget, nFeedBack);
		motor[Lift]=75;
		}
		float nFeedBack=(nMotorEncoder[Lift]/1120)/22.5;
		writeDebugStreamLine("Value :%f Target: %f, Location: %f", nMotorEncoder[Lift], nTarget, nFeedBack);
		motor[Lift]=0;
	}
	if(nTarget<1)//run down
	{
		while(nMotorEncoder[Lift]>=nTarget)//if switch is pressed break...
		{
		writeDebugStreamLine("Value :%i, Target: %i", nMotorEncoder[Lift], nTarget);
		motor[Lift]=-75;
		}
		motor[Lift]=0;
	}
}

void Drive(int distance, int power)
{
	int C=2*(PI)*2;
	int Target= (1120/C)*distance;//en/in
	nMotorEncoder[Right]=0;
	if(distance>1)
	{
		while(nMotorEncoder[Right]<=Target)
		{
		writeDebugStreamLine("Value :%i, Target: %i",nMotorEncoder[Right], Target);
		motor[Right]=power;
		motor[Left]=power;
		}
		motor[Right]=0;
		motor[Left]=0;
	}
	else if(distance<1)
	{
		while(nMotorEncoder[Right]>=Target)
		{
		writeDebugStreamLine("Value :%i, Target: %i",nMotorEncoder[Right]*-1, Target);
		motor[Right]=-power;
		motor[Left]=-power;
		}
		motor[Right]=0;
		motor[Left]=0;
	}
}

void Turn(int Angle)//clockwise is negitive
{

	float circumfrence = 2*(PI)*2;
	int ppr = 1120;
	int enc_in=ppr/circumfrence;//result+

	float WheelbaseRadius = 5.3875;
	float ArcLength=degreesToRadians(abs(Angle))*WheelbaseRadius;//result

	int Target= round(ArcLength*enc_in);//goal

	writeDebugStreamLine("Target:%i",Target);
  nMotorEncoder[Right]=0;
  nMotorEncoder[Left]=0;
  //1/2 rot= 45deg = 1120enc
	if(Angle<1)
	{
	//left
		while(-1*(nMotorEncoder[Left])<= Target)
		{
		motor[Right]=60;
		motor[Left]=-60;
		writeDebugStreamLine("Encoder:%i",nMotorEncoder[Left]);
		}
		motor[Right]=0;
		motor[Left]=0;
	}
	else if(Angle>1)
	{
	//right
		while(nMotorEncoder[Left]<= Target)
		{
		motor[Right]=-60;
		motor[Left]=60;
		writeDebugStreamLine("Encoder:%i",nMotorEncoder[Left]);
		}
		motor[Right]=0;
		motor[Left]=0;
	}
}

void BumpConveyor()
{
motor[Conveyor]=75;
wait10Msec(100);
motor[Conveyor]=0;
wait10Msec(50);
motor[Conveyor]=75;
wait10Msec(0.75);
motor[Conveyor]=0;
}

void Test()
{
//Turn(-90);
//Drive(1.5);
//Drive(-1.5);
//RunLift(4);
//BumpConveyor();
//Drive(1.5);
//RunLift(-4);
//Drive(-1.5);
//Turn(90);
//Drive(12);
//Turn(90);
//Drive(36);
}
